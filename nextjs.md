# [NEXT.JS](https://nextjs.org/)

## Inicializacion

Para inicializar una proyecto con nextjs usaremos el coamando:
```
npx create-next-app nombre_proyect
```
Si tambien queremos usar typescript con nextjs usamos:
```
npx create-next-app@latest nombre_proyect --ts
```

Se podran usar los comandos:
`npm run dev`
    Starts the development server.

`npm run build`
    Builds the app for production.

`npm start`
    Runs the built app in production mode.

Antes que nada utilizaremos el comando:
```
npm run dev
```
ESto para que se cree la capeta de .next que es necesaria para que funcione todo bien.

### Estructura de carpetas

En esta ocacion vamos a usar next + typescript


Se creo una carpeta llamada `pages` en esta existe el `index` de nuestra aplicacion(donde esta todo el contenido de la aplicacion). Dentro de `pages` tambien existe un derectorio para las `api`.

Dentro del archivo `pages/index.tsx`:
```tsx  
import Head from 'next/head';
// importa una utilidad que tiene nextjs para cambiar todo lo que tiene envuelto de head
//head es la etiqueta html especial para el title, la description, metadatos, etc

//una eejmplo de uso seria:
<Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
</Head>
```

**_app.tsx**
Este es un fichero especial, se encuentra en `pages/_app.tsx`. Este fichero detecta cuando se quiere hacer un componente que es el que envuelve la aplicacion.

Se pueden encontrar otras soluciones o usar este fichero.

**_document**
Similar al _app pero este se encuentra en una escala mas profunda ya que te puedes meter con el html tambien.

Algo que tomar en cuenta es que el document esta renderizado en el servidor, solo se renderiza en el servidor y no se renderiza en el cliente.

Aqui es donde se podria hacer uso del google analitics


### Crear rutas
Para crear una ruta mas simplemente tenemos que crear un directorio dentro de la carpteta `pages`. Ejemplo:
`pages/new_page/index.js`, se tiene que crear un index dentro del nuevo directorio para que se cree la ruta.

### Navegacion SPA

Si fuera un SPA no tendria que recargar la pagina sino que cargaria solamente lo que necesita.

```tsx
import Link from "next/link";
//en lugar de usar un a tenemos que sar un Link 
// asi usara el sistema de spa de nextjs y asi se evite recargar la apgina entera 

//<a href="/example">page example</a>
<Link href="/example">page example</Link>

//si llega a salir un error con los link entonces usarlos:
<Link href="/example">
<a>
page example
</a>
</Link>
```

**Fast Refresh**
Se hacen cambios en la pagina sin tener que reflescarla.

**newxt router**
```js
import {useRouter} from "next/router"
const router = useRouter();
const.log(router)
```

**componentes**
Para integrar componentes tenemos que crear la carpeta `components` al mismo nivel que la carpeta `pages` **no** dentro de la carpeta `pages`.


### Obtener datos en Next.js

Al obtener datos con Next.js, tiene algunas opciones sobre cómo desea obtener esos datos.

Primero, puede ir a la ruta del lado del cliente y realizar la solicitud una vez que se carga la página. El problema con esto es que le estás poniendo la carga al cliente para que se tome el tiempo de hacer esas solicitudes.

Las API de Next.js gustan `getStaticProps` y `getServerSideProps` le permiten recopilar datos en diferentes partes del ciclo de vida, lo que nos brinda la oportunidad de crear una aplicación completamente estática o una que se represente en el lado del servidor. Eso servirá los datos ya representados en la página directamente al navegador.

Al usar uno de esos métodos, podemos solicitar datos junto con nuestras páginas e inyectar esos datos como accesorios directamente en nuestra aplicación.

## Next.js + Apollo + GraphQL 

Para comenzar a realizar una consulta GraphQL, necesitaremos un cliente GraphQL. Usaremos el cliente Apollo GraphQL.

De vuelta dentro de la terminal, ejecute el siguiente comando para instalar nuestras nuevas dependencias:

```
npm install @apollo/client graphql
```

Esto agregará el cliente Apollo y GraphQL, que necesitaremos para formar la consulta GraphQL.

Y una vez que se complete la instalación, estaremos listos para comenzar a usar Apollo Client.

### agregar datos a una página Next.js con getStaticProps

Antes de obtener datos con Apollo, vamos a configurar nuestra página para poder solicitar datos y luego pasar esos datos como apoyo a nuestra página en el momento de la compilación.

Definamos una nueva función en la parte inferior de la página debajo de nuestro Homecomponente llamada getStaticProps:

```js
export async function getStaticProps() {
  // Code will go here
}
```
Cuando Next.js construye nuestra aplicación, sabe buscar esta función. Entonces, cuando lo exportamos, le informamos a Next.js que queremos ejecutar el código en esa función.

Dentro de nuestra `getStaticProps` función, finalmente devolveremos nuestros accesorios a la página. Para probar esto, agreguemos lo siguiente a nuestra función:
```js
export async function getStaticProps() {
  return {
    props: {
      launches: []
    }
  }
}
```

Aquí, estamos pasando una nueva propiedad `launches` y configurándola en una matriz vacía.

Ahora, volviendo al interior de nuestro Homecomponente, agreguemos un nuevo argumento desestructurado que servirá como nuestro accesorio junto con una `console.log` declaración para probar nuestro nuevo accesorio:

Si recargamos la página, podemos ver que ahora estamos desconectando nuestra nueva propiedad `launches` que incluye una matriz vacía tal como la definimos.

Lo mejor de esto es que, dado que la `getStaticProps` función que estamos creando es asíncrona, podemos realizar cualquier solicitud que deseemos (incluida una consulta de GraphQL) y devolverla como accesorios a nuestra página, que es lo que haremos a continuación. 

### Obtener datos con una consulta GraphQL en Next.js usando Apollo Client

Ahora que nuestra aplicación está preparada para agregar accesorios a la página y tenemos Apollo instalado, finalmente podemos hacer una solicitud para obtener nuestros datos.

Aquí, vamos a utilizar el cliente Apollo, que nos permitirá interactuar con el servidor SpaceX GraphQL. Haremos nuestra solicitud a la API utilizando el método getStaticProps de Next.js, lo que nos permitirá crear accesorios de forma dinámica para nuestra página cuando se construya.

Primero, importemos nuestras dependencias de Apollo al proyecto. En la parte superior de la página agregue:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';
```
Esto incluirá el propio Apollo Client, `InMemoryCache` que permite a Apollo optimizar mediante la lectura de la memoria caché, y `gql` que usaremos para formar nuestra consulta GraphQL.

A continuación, para usar Apollo Client, debemos configurar una nueva instancia de este.

Dentro de la parte superior de la getStaticPropsfunción, agregue:
```js
const client = new ApolloClient({
  uri: 'https://api.spacex.land/graphql/',
  cache: new InMemoryCache()
});
```

Esto crea una nueva instancia de Apollo Client usando el extremo de la API de SpaceX que usaremos para consultar.

Con nuestro cliente, por fin podemos hacer una consulta. Agregue el siguiente código debajo del cliente:

```js
const { data } = await client.query({
  query: gql`
    query GetLaunches {
      launchesPast(limit: 10) {
        id
        mission_name
        launch_date_local
        launch_site {
          site_name_long
        }
        links {
          article_link
          video_link
          mission_patch
        }
        rocket {
          rocket_name
        }
      }
    }
  `
});
```

Esto hace algunas cosas:

- Crea una nueva consulta GraphQL dentro de la `gql` etiqueta
- Crea una nueva solicitud de consulta usando `client.query`.
- Se utiliza `await` para asegurarse de que finaliza la solicitud antes de continuar.
- Y finalmente se desestructura `   ` a partir de los resultados, que es donde se almacena la información que necesitamos

Dentro de la consulta de GraphQL, le estamos diciendo a la API de SpaceX que queremos obtener `launchesPast`, que son los lanzamientos anteriores de SpaceX, y queremos obtener los últimos 10 (límite). Dentro de eso, definimos los datos que nos gustaría consultar.

Si nos tomamos un segundo para agregar una nueva declaración de registro de la consola después de eso, podemos ver cómo `data` se ve.

Sin embargo, una vez que actualice la página, notará que no está viendo nada dentro de la consola del navegador.

`getStaticProps` se ejecuta durante el proceso de compilación, lo que significa que se ejecuta en node. Por eso, podemos mirar dentro de nuestra terminal y podemos ver nuestros registros allí:

Después de ver eso, sabemos que dentro del `data` objeto tenemos una propiedad llamada `launchesPast`, que incluye una serie de detalles de lanzamiento.

Ahora, podemos actualizar nuestra declaración de devolución para usar `launchesPast`:

Y si volvemos a agregar nuestra `console.log` declaración en la parte superior de la página para ver cómo se ve nuestro `launches` accesorio, podemos ver que nuestros datos de lanzamiento ahora están disponibles como un accesorio para nuestra página:
```js
return {
  props: {
    launches: data.launchesPast
  }
}
```



### agregar datos de lanzamiento de SpaceX a la página

Tenemos nuestros datos de lanzamiento que pudimos usar Apollo Client para solicitar del servidor SpaceX GraphQL. Hicimos esa solicitud `getStaticProps` para que pudiéramos hacer que nuestros datos estén disponibles como el `launches` accesorio que contiene nuestros datos de lanzamiento.

Indagando en la página, vamos a aprovechar lo que ya existe. Por ejemplo, podemos comenzar actualizando la `h1` etiqueta y el párrafo debajo de ella a algo que describa nuestra página un poco mejor.

A continuación, podemos usar las tarjetas de enlace ya existentes para incluir toda nuestra información de lanzamiento.

Para hacer esto, primero agreguemos una declaración de mapa dentro de la cuadrícula de la página, donde el componente que devolvemos es una de las tarjetas, con los detalles de lanzamiento completados:

```js
<div className={styles.grid}>
  {launches.map(launch => {
    return (
      <a key={launch.id} href={launch.links.video_link} className={styles.card}>
        <h3>{ launch.mission_name }</h3>
        <p><strong>Launch Date:</strong> { new Date(launch.launch_date_local).toLocaleDateString("en-US") }</p>
      </a>
    );
  })}
```

Desde aquí, podemos incluir cualquier dato adicional desde el interior de nuestra `launches` matriz en nuestra página. La API incluso incluye imágenes de parches de misión, que podemos usar para mostrar buenos gráficos para cada lanzamiento.

Incluso puede agregar datos adicionales a la consulta de GraphQL. Cada lanzamiento tiene mucha información disponible, incluido el equipo de lanzamiento y más detalles sobre el cohete.


 para saber si estar en el servirdor o en el cliente:
typeof window !== "undefined"

https://www.youtube.com/watch?v=2jxc8DMzt0I

1:11:00
## NEXTJS + MONGOB

Mongodb nos da un modulo para node para poder conectarlo pero en esta ocacion vamos a usar un modulo especial de mongodb llamado [mongoose](https://mongoosejs.com/),que es basicammente un modulo que nos permite conectarnos a la base de datos y tambien a su vez modelar los datos, es decir, decirle a mongodb que es lo que vamos a estar guardando dentro de la base de datos.


Despues abriremos el archivo `pages/api/hello.ts/`

SI queremos abrir este archivo desde el navegador entonces encendemos el servidor e ingresamos a la ruta:
```
localhost:3000/api/hello
```
ESto va a mostrar un objeto `.json`, es un objeto por que por lo general el backend devuelve objetos `.json` como forma de dar datos al cliente.

Next por debajo usar `express`.

Ahora crearemos un nueva nueva carpeta `pages/api/tasks/`, esta carpeta `tasks` nos va a servir para crear un CRUD  de tareas, es decir, vamos a crear los endpoinds o urls basicos que nos van a permitir crear tareas en el backend, eliminar, actualizar y obtener una unica tarea.

Ahora vamos a crear un archivo  `pages/api/tasks/index.js` y dentro de el vamos a escribir:
```ts
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json("tasks")
}


```

SI queremos abrir este archivo desde el navegador e ingresamos a la ruta:
```
localhost:3000/api/tasks
```
nos aparecera el string `tasks`

ahora vamos a instalara `mongoose`:
```
npm i mongoose
```

y vamos a crear un nuevo archivo al mismo nivel que `packagejson`, este archivo se va a nombrar `.env`, dentro de esta archivo vamos a escribir la direccion de la base de datos de mongodb(como variable de entorno)
```
MONGO_URL= mongodb://localhost:27017/nextjsmongodb
``` 
nuestra base de datos, en esta ocacion, se va a llamar `nextjsmongodb`.
Nosotros no tenemos que crear esta base de datos, en mongodb cuando nos conectamos a una base de datos este lo crea por nosotros.

Ahora si vemos el `.gitignore` se puede observar que esta ignorando:
```js
.env.local
.env.development.local
.env.test.local
.env.production.local
```
y vamos a agregar el `.env` para que no se suba a github:
```js
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
```

En lugar de un string lo que queremos devolver es una lista de tareas pero esas tareas tienen que estar guardadas en algun lugar y para eso necesito una base de datos.

Para conectarnos a una base de datos nosotros podemos crear una carpeta al mismo nivel que la carpeta `pages` **no** dentro de esta misma. En esta ocacion vamos a crear una carpeta con el nombre `utils` en esta carpeta podemos crear un archivo de conexion, es decir, un archivo que va a tener la conexion de la base de datos `utils/mongoose.ts`

`mongoose.ts`:
```ts
import {connect,connection} from "mongoose";
// connection da una serie de eventos para detectar cuando la coneccion se haya hecho, si ocurrio un error o si paso algo

export async function dbConect(){
    //dbConect lo que haces es inicialmente va intentar concetarse con la base de datos
    //pero para hacerlo tenermos que especificar a que base de datos se va a tener que concectar 
    // por lo general es comun que se le pase una direccion url de mongo db
    //pero a la hora de despegar la aplicacion no se va a querer colocar la direccion de la base de datos directamente en codigo asi que vamos a usar una variable de entorno del archivo .env
    const db: any = await connect(process.env.MONGO_URL)
    // lo anterior va a devolver un objeto db y si este existe va a devolver un estado
    //.readyState: para mostrar el estado, si esta listo o no
    console.log(db.connections[0].readyState)

}

connection.on("connected", ()=>{
    console.log("Mongodb is connected")
})

connection.on("error", (err)=>{
    console.log(err)
})
```

ahora en el archivo de `pages/api/tasks/index.ts` vamos a importar `mongoose.ts`:
```ts
import type { NextApiRequest, NextApiResponse } from 'next'
import {dbConect}  from "../../../utils/mongoose"
type Data = {
  name: string
}

dbConect()

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'tasks' })
}


```


Ahora tenemos que iniciar la base de datos de mongo:
```
mongod
```

si ocurero un error es por que `node` v17 prefiere las direcciones IPv6 a las IPv4. Pero mongo está configurado de manera predeterminada con ipv4.

- Configuración de IPv4
```
net:
  port: 27017
  bindIp: 127.0.0.1
```
- Configuración de IPv6
```
 net:
      ipv6: true
      port: 27017
      bindIpAll: true
```

en las rutas:
OSX path : `/usr/local/etc/mongod.conf`
Ubuntu Path: `/etc/mongod.conf`

Luego reinicie mongo.
```
sudo systemctl restart mongod
```

Algo que ocurre en nextjs es que cada vez que que estemos creando rutas para nuestro backend vamos a tener que estar importando la conexion a la base de datos, pero si importams el `dbConect` cada vez se va a crear una conexion nueva, para arreglar esto tenemos que guardar la conexion y poner una condicional, si ya existe la conexion vamos a utilizarla

```ts
import {connect,connection} from "mongoose";

const conn = {
    isConnected: false
  }
  

export async function dbConect(){

    //creamos una condiconal para usar la coneccion ya existente a la base de datos y asi no se creen nuevas con cada import a otros archivos
    if(conn.isConnected) return;
   
    const db: any = await connect(`${process.env.MONGO_URL}`);

    conn.isConnected = db.connections[0].readyState;

    console.log(db.connection.db.databaseName)

}

connection.on("connected", ()=>{
    console.log("Mongodb is connected")
})

connection.on("error", (err)=>{
    console.log(err)
})
```

### consultas mongodb en nexjs

Para hacer una consulta desde nexjs a mongodb tenemos que crear primero una carpeta con un archivo `models/task.ts` al mismo nivel que `pages` **no** dentro de esta misma.

Esta carpeta `models` va a contener un modelo de datos de lo que la base de datos tiene. Desntro del archivo `task.ts` escribimos:

```ts
import { Schema,model,models } from "mongoose";
// Schema: nos va apermitir definir los parametros y datos queremos guardar
// model: nos permite crear el modelo
// models: nos va a permitir saber cuantos modelos tenemos creados en nuestra conexion

// le indicamos que queremos que las tareas tengan las propiedades:
// [true, "Title is required"] : en caso de que no se mande el titulo se va a imprimir el string
// trim : true: va aquitar los espacios del final y del inicio del title

//timestamps: true : adicionalmente al titulo yd escription le va agregar dos campos mas (la fehca de cuando se creo y la fecha de cuando se actualizo)
const taskSchema = new Schema({
    title:{
        type:String,
        required: [true, "Title is required"],
        unique: true,
        trim : true,
        maxlength: [40, "Title must be less than 40 characters"]
    },
    description:{
        type: String,
        required: true,
        trim: true,
        maxlength: [200, "Title must be less than 200 characters"]
    }
},{
    timestamps: true,
    versionKey : false
})

//ahora lo importaremos como un modelo
//model recibe dos parametros, un nombre y el Schema
// crearemos una condicional 
// si el model ya ha sido creado usaremos dicho modelo existente y no lo volveremos a crear
export default models.Task || model("Task", taskSchema)
```
 Ahora que tenemos un modelo lo tener que importarlo en `pages/api/tasks/inde.ts`:

 ```ts
 import type { NextApiRequest, NextApiResponse } from 'next'
import {dbConect}  from "../../../utils/mongoose";
import Task from "../../../models/task";
// este modelo Task ya nos permite hacer consultas a la base de datos

type Data = {
  name: string
}

dbConect()

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  //ahora haremos una consula con el modelo Task
  //Task tiene un metodo llamado find(), este metodo find es asincrono 
  const tasks = await Task.find();
  console.log(tasks)
  res.status(200).json(tasks)
}
```

Esto nos tendria que devolver un array en blanco `[]`, por consola, por que no tenemos datos en la base de datos aun. `http://localhost:3000/api/tasks`

#### [Absolute Imports and Module path aliases](https://nextjs.org/docs/advanced-features/module-path-aliases)

Para evitar tipear rutas largas en los imports podemos usar la opcion `"baseUrl": "."` en el archivo `tsconfig.json or jsconfig.json`
```js
// tsconfig.json or jsconfig.json
{
  "compilerOptions": {
    "baseUrl": "src"
  }
}
```
Lo que tenemos gracias a esto es que ahora la base de las rutas de nuestro proyecto es la carpeta `src` la cual es la carpeta que usamos para todo el codigo de nuestro proyecto.

SI llega a ocurrir un error hay que eliminar la carpeta `.next` y volver a ejecturar `npm run dev`

### Validacion de peticiones

**GET**
```ts
import type { NextApiRequest, NextApiResponse } from 'next'
import {dbConect}  from "utils/mongoose";
import Task from "models/task";


/*type Data = {
  name: string
}
*/
dbConect()

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  //para validar las peticiones crearemos condicionales
  //cuando tenemos una peticion el objeto `req` nos da informacion de la peticion que se esta haciendo 
  // req.query //da informacion de la query (lo que viene en una consulta)
  // req.url //da informacion de la url que esta llegando ejemplo: /api/pasks
  // req.method  Ejemplo: get
  switch (req.method) {
    case "GET":
      const tasks:any = await Task.find();
      return res.status(200).json(tasks);
    default:
      return res.status(400).json({msg:"this method is not supported"});
  }
}
```
**POST**

Apartir de aqui ya necesitamos un cliente `rest` por que vamos a hacer otro tipo de peticiones. Un cliente `rest` me permite hacer las otras peticiones POST,PUT,DELETE. Un cliente rest que funciona dentro de VisualStudioCode de llama `thunder client` para hacer peticiones estilo postman dentro de la aplicacion . Otra opciones eria el `REST Client` tambien de VisualStudioCode el cual nos permite consultar desde un archivo, en esta ocacion usaremos `thunder client`.

En `thunder client` cuando hacemos click al boton `New Request` nos dan varias opciones. En el apartado de `Body` podremos poner un contenido en diferentes formatos para que el servidor lo resiva y pueda ver con `req.body`:

```json
//Json Content
{
  "title": "my first task", 
  "description": "this is my first description"
}
```

y modificamos el `index.ts` para que acepte peticiones "POST":
```TS
import type { NextApiRequest, NextApiResponse } from 'next'
import {dbConect}  from "utils/mongoose";
import Task from "models/task";


/*type Data = {
  name: string
}
*/
dbConect()

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const {method, body} = req;

  switch (req.method) {
    case "GET":
      try {
        const tasks:any = await Task.find();
        return res.status(200).json(tasks);
      } catch (error) {
        return res.status(400).json({error: error.message})
      }
      
    case "POST":
      try {
        
      //el metodo POST lo que va hacer primero es recibir las datos que le envie el cliente atravez de:
      //req.body
      // este seria el objeto que esta creado mongoose
      const newTask = new Task(body); //esto solo crea un objeto nuevo
      // luego lo vamos a guardar en la base de datos
      const savedTask = await newTask.save();
      // y finalmente lo retornamos
      return res.status(201).json(savedTask)
      } catch (error) {
        return res.status(400).json({error:error.message})
      }


    default:
      return res.status(400).json({msg:"this method is not supported"});
  }
}


```

Y en `thunder client` hacemos una peticion POST al link `http://localhost:3000/api/tasks` y la respuesta del backend es:
```json
{
  "title": "my first task",
  "description": "this is my first description",
  "_id": "61edff4f7f386c312acfd6da",
  "createdAt": "2022-01-24T01:22:23.291Z",
  "updatedAt": "2022-01-24T01:22:23.291Z"
}
```

Ahora vamos a crear las indicacion para obtener una sola tarea, eliminar una sola tarea y actualizar una tarea, para hacer esto tener que enviarle un id de la tarea que ya existe".

Tener que crear un archivo dentro de `pages/api/task/` con el nombre de `[id].ts` entre nombre entre llaves significa que lo que esta dentro de los braquets es para que se considere como un parametro, es decir, eso va a ir cambiando, esto lo hacemos por que no sabes que id va a ser.

`[id].ts`: 
```ts
export default async (req,res) => {
    //en esta ocacion queremos ver el parametro 
    // para ver los datos de la consulta : req.query
    console.log(req.query)
    return res.status(200).json("reiceved")
};
```

Ahora si en el navegador visitamos la url `http://localhost:3000/api/tasks` podremos ver el mensaje de `received` y en la consola `{id:100}`

**GET ONE**.
Obtendremos una tarea con un id
```TS
import type { NextApiRequest, NextApiResponse } from 'next';
import {dbConect}  from "utils/mongoose";
import Task from "models/task";

dbConect();

export default async function requestId(req: NextApiRequest,
    res: NextApiResponse) {
    const {method,body,query:{id}} = req;

    switch(method){
        case "GET":
            try {
              //findById : permite buscar por id
                const task = await Task.findById(id);
                if(!task) return res.status(404).json({msg:"Task not found"});
            return res.status(200).json(task)
            } catch (error) {
                return res.status(500).json({msg:error.message})
            }

            
        case "PUT":

        case "DELETE":

        default:
            return res.status(400).json({msg:"this method is not supported"});
    }
};
```
Ahora si en el navegador visitamos la url `http://localhost:3000/api/61edff4f7f386c312acfd6da` podremos ver el mensaje que nos devuelve la tarea con dicho id.

**DELETE ONE**
```TS
import type { NextApiRequest, NextApiResponse } from 'next';
import {dbConect}  from "utils/mongoose";
import Task from "models/task";

dbConect();

export default async function requestId(req: NextApiRequest,
    res: NextApiResponse) {
    const {method,body,query:{id}} = req;

    switch(method){
        case "GET":
            try {
                const task = await Task.findById(id);
                if(!task) return res.status(404).json({msg:"Task not found"});
                return res.status(200).json(task)
            } catch (error) {
                return res.status(500).json({msg:error.message})
            }            
        case "PUT":

        case "DELETE":
            try {
                //findByIdAndDelete : permite eleminar una tarea con un id
                const deletedTask = await Task.findByIdAndDelete(id);
                // mongoose cuando elimina un dato se lo devulve 
                if(!deletedTask) res.status(404).json({msg: "Task not found"});
                return res.status(200).json(deletedTask);
                // otra foorma de return seria:
                // todo salio bien pero no regresa nada:
                // return res.status(204);
            } catch (error) {
                return res.status(400).json({msg:error.message})
            }

        default:
            return res.status(400).json({msg:"this method is not supported"});
    }
};
```
Ahora si usamos ``THINDER CLIENT` y hacemos una peticion `DELETE` a la url `http://localhost:3000/api/61edff4f7f386c312acfd6da` podremos ver como se elimina dicha tarea y de respuesta obtendremos la tarea eliminada.

**PUT ONE**
```ts
import type { NextApiRequest, NextApiResponse } from 'next';
import {dbConect}  from "utils/mongoose";
import Task from "models/task";

dbConect();

export default async function requestId(req: NextApiRequest,
    res: NextApiResponse) {
    const {method,body,query:{id}} = req;

    switch(method){
        case "GET":
            try {
                const task = await Task.findById(id);
                if(!task) return res.status(404).json({msg:"Task not found"});
                return res.status(200).json(task)
            } catch (error) {
                return res.status(500).json({msg:error.message})
            }            
        case "PUT":
            try {
                // el id es la tarea que quiere ser actualizada 
                // el body son los nuevos datos
                // al actualizarse un objeto este retorna el objeto antiguo
                // por esta razon se le pasa al la funcion findByIdAndUpdate el objeto new: true
                // para que asi retorne el objeto nuevo y no el objeto antiguo
                const taskUpdate = await Task.findByIdAndUpdate(id, body,{new : true});
                
                if(!taskUpdate) return res.status(400).json({msg:"Task not found"});
                return res.status(200).json(taskUpdate)
            } catch (error) {
                return res.status(500).json({msg:error.message})
            }
        case "DELETE":
            try {
                
                const deletedTask = await Task.findByIdAndDelete(id);
                
                if(!deletedTask) res.status(404).json({msg: "Task not found"});
                return res.status(200).json(deletedTask);
            } catch (error) {
                return res.status(400).json({msg:error.message})
            }

        default:
            return res.status(400).json({msg:"this method is not supported"});
    }
};
```

Ahora si usamos ``THINDER CLIENT` y hacemos una peticion `PUT` a la url `http://localhost:3000/api/61edff4f7f386c312acfd6da` y luego en la opcion de `Body` tenemos que ingresar los datos que queremos actualizar:
```json
//Json Content
{
  "title": "titulo actualizado",
  "description" : "descripcion actualizada"
}
```

#### Pedir datos al backend desde el frontend

Desde un componente:
```ts
import type { NextPage } from 'next';
import Head from 'next/head';
//import Image from 'next/image'
import styles from '../styles/Home.module.css';
import Link from "next/link";

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>Next Type</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1>Next Type</h1>
        <Link href="/example"><a>
        page example
        </a></Link>
      </main>

    </div>
  )
}

export default Home

export async function getServerSideProps(){
  const res = await fetch("http://localhost:3000/api/tasks");

  const tasksAll = await res.json()
  console.log(tasksAll)

  return {
    props:{}
  }
}
```

En este caso lo hicimos en el componente `home`, ahora si en el navegador vamos al home `http://localhost:3000/` vemos que sigue igual pero en la terminal de node veremos las tareas.

## Obtener datos de backend

En Nextjs existe una funcion especial que nos permite obtener datos desde frontend o backend.

Cuando se crea un componente ,importamos react y usamos un `useEffect()`, basicamente, es como si extuvieramos importanto datos desde el frontend.

Pero si quisieramos traer datos desde el backend hay una funcion especial llamada `getServerSideProps`.

En [Data Fetching](https://nextjs.org/docs/basic-features/data-fetching) nos preveen de varios metodos que basicamente sirven para traer datos en dos formatos:

- `getServerSideProps`:  Consulta la api, los datos los pasa al frontend y en el fronten lo puede reutilizar. Pero realiza un proceso consume mas recursos en un servidor pero como ventaja obtiene el seo, es decir que el navegador obtiene un tipo de previsualizacion de la pagina que se va a pintar.

- `getStaticProps` : cuando hacemos una peticion  `getStaticProps` los convierte en un archivo html en donde esta todo ya pintado y cuando se pide hacie el cliente autimaticamente ya estaria generado ese html, no se tendria que pedir ningun dato.

En este caso usaremos `getServerSideProps`:
```ts
import type { NextPage } from 'next';
import styles from '../styles/Home.module.css';

//el props de getServerSideProps pasa el props de Home
const Home: NextPage = (props) => {
  console.log("frontend")
  return (
    <div className={styles.container}>
      <h1>Hello world</h1>
    </div>
  )
}

export default Home

export const getServerSideProps = async()=>{
  
  console.log("backend!!")

  //es obligatorio el retornar el objeto con props dentro
  return {
    props:{}
  }
}
```

cuando se ejecute en la **consola del navegador** se mostrara `frontend` y en la consola te la terminal se mostrara:
```
backend!!
frontend
```
Esto es por que las propiedades pasan tambien por el front.

Y de esta forma podemos comunicar el backend con el frontend

```ts
import type { NextPage } from 'next';
//import Head from 'next/head';
//import Image from 'next/image'
import styles from '../styles/Home.module.css';
//import Link from "next/link";



const Home: NextPage = ({tasks}) => {
  // con map podemos recorrer el objeto tasks
  console.log(tasks)
  return (
    <div className={styles.container}>
      <h1>Hello world</h1>
    </div>
  )
}

export default Home

export const getServerSideProps = async()=>{
  
  const res = await fetch("http://localhost:3000/api/tasks");
  const tasks = await res.json();
  return {
    props:{
      tasks
    }
  }
}
```
Esto mostraria las tareas en la consola del navegador y mostraria mas detalladamente como pasan los datos de backen a frontend

## nav para todas las paginas

Todas las paginas pasan por `src/pages/_app.tsx` asi podriamos poner un componente en dicho archivo para que se muestre es los demas componentes.

crearemos una carpeta `src/components/Layout.tsx`, este `Layout.ts` nos va a pemitir el colocar una estrucura en comun, es decir, crear una navegacion para todas las paginas, un footer para todas la paginas, etc.

y tambien crearemos un archivo `src/components/Navbar.tsx`:
```tsx

import Link from "next/link";
import { useRouter } from "next/router";
//useRouter nos permite movernos entre paginas con una function
//Link es como un a de html pero esto no recarga la pagina para cambiar de pesta;as

const Navbar = () => {

    const router = useRouter();

  return (<header>
      <div>
          {/*EL favicon y el vercel se encuentran en la carpeta bublic */}
          {/*Si en el navgeador buscamos: localhost:300/favicon.ico */}
          {/*SI buscamos eso nos mostrara el favicon.ico entonces nosotros podemos hacer referencia a el no desde las carpetas sino desde la direccion de las pesta;as, lo mismo con el vercel.svg */}
          <img src="/vercel.svg" alt="ico"/>
        </div>
      <nav>
          <ul>
              <li>
                  {/*Este boton nos regresara el home sin que se refresque la pagina */}
                  {/*Tambien le podemos poner etiquetas img dentro para que al momento de datle click a una imagen esta nos refireccione a otra page */}
                  <Link href="/">Home</Link>
              </li>
              <li>
                  <input type="button" onClick={()=> router.push("/task/new")}>new</input>
              </li>
          </ul>
      </nav>
  </header>);
};

export default Navbar;


```

y dentro de `Layout.tsx`:

```tsx
import Navbar from "./Navbar";


const Layout = ({children}) => {
  return( 
    <>
    <Navbar/>
    {children}
    </>);
};

export default Layout;

```

Ahora para que se vea en todas la paginas es escribir en `src/pages/_app.tsx`:

```tsx
import '../styles/globals.css'
import type { AppProps } from 'next/app'
import Layout from 'components/Layout'



function MyApp({ Component, pageProps }: AppProps) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  )
  
}

export default MyApp

```

### next/error

Nextjs nos da una pagina para nuestros errores:

```tsx
import Error from "next/error"
//nos da un componente en el cual podemos pasarle un titulo y un texto por pantalla
export default function task (){
  return(
    <Error statusCode={404} title="This is not the web page you are looking for"/>
    
  )
} 
```
#### next/imge

## NextJS + GraphQL

Instalamos las dependencias
```
npm @apollo/client graphql
```

en `pages/index.j`:
```js
import {useState} from "react";
import {ApolloClient, InMemoryCache, gql} from "@apollo/client"

export default function Home(results){
  const initialState = results;
  const [characters,setCharacters] = useState(initialState.characters)
}

export async funcion getStaticProps(){
  const client new ApolloClient({
    uri: "https//rickandmortyapi.com/graphql",
    cache: new InMemoryCache(),
  });
  const {data} = await client.query({
    query: gql`
      query {
        characters(page:1){
          info{
            count
          }
        }
      }
    `
  });
  return {
    props:{
      characters: data.characters.info
    }
  }
}
```

## apollo-server-micro + nextjs

Intalaremos Apollo Server Micro por que esta optimizada para entornos sin servidor y Next.js
```
npm install apollo-server-micro graphql micro-cors
```

En la carpeta raiz se creara un carpeta llamda `grapql`, esta carpeta tendra todo lo relacionado con nuestra API de GraphQL. Dentro de esta carpeta se creara un nuevo archivo llamado `schema.ts`, en este archivo definiremos el esquema graphql para la aplicacion:
```ts
import {gql} from "apollo-server-micro";
export const typeDefs = gql`
  type Link{
    id: String
  }
  type Query{
    links: [Links]!
  }
`
```

Ahora crearemos el documento de los resolvers en la misma carpeta y lo llamaremos `resolvers.ts`:
```ts
export const resolvers = {
  Query: {
    links: () => [
      {id: "asfsdfssa-asfsf-156465-asdas"}
    ]
  }
}
```

Ahora el siguiente paso es conbian el `schema` con los `resolvers` y ahi es donde entra en juego Apollo Server.

Nextjs es un marco de trabajo de pila completa y tiene una caracteristica realmente genial y son las rutas API.

Dentro de la carpeta `pages` se encuentra la carpeta `api`, dentro de la carpte `api` crearemos el archivo `graphql.ts`:

```ts
import {ApolloServer} from "apollo-server-micro";
import {typeDefs} from "../../graphql/schema";
import {resolvers} from "../../graphql/resolvers";
import Cors from "micro-cors";

const cors = Cors()

const apolloServer = new ApolloServer({typeDefs, resolvers});


//tambien queremos definir una function para iniciar el servidor, este es un requisito para apollo server
// debe tener una funcion que inicie el servidor antes de crear el punto final
const startSever = apolloSever.start()

//ahora mismo NextJS aun no esta al tanto de este punto final, EN realiadm necesitamos hacer una exportacion predeterminada 
export default cors(
  
  async function headler(req,res){

    if(req.method === "OPTIONS"){
      res.end()
      return false;
    }
    await startServer;
  
    //path: especificaremos la rua de nuestro servidor graphql
    await apolloServer.createHandler({
      path: "api/graphql"
    })(req,res);
  }
) 

//lo utimo que haremos es en realidad este analisis de cuerpo capacitado
//eso es por que se maneja de forma predeterminada en graphql 
// para esto tendremos que especificarle a nextjs:
export const config = {
  api:{
    bodyParser:false
  }
}
```

Con esto ya tendriamos creado un servidor de GrahQl

## Apollo server + apollo client

**apollo server**

`pages/api/graphql.js`:
```ts
import { ApolloServer, gql } from 'apollo-server-micro'
import Cors from "micro-cors";




const persons = [
  {
      name: "Midu",
      city: "Barcelona"
  },
  {
      name: "Youseff",
      city: "Mataro"
  },
  {
      name: "Itzi",
      city: "Ibiza"
  }
]

const typeDefs = gql`
  type Person {
    name: String!
    city: String!
  }
  type Query {
    allPersons: [Person]!
  }
`

const resolvers = {
  Query: {
    allPersons: () => persons
  },
}

const cors = Cors();

const apolloServer = new ApolloServer({ typeDefs, resolvers });

const startServer = apolloServer.start();

export default cors( async function handler(req, res) {
  
  if (req.method === 'OPTIONS') {
    res.end()
    return false
  }

  await startServer
  await apolloServer.createHandler({
    path: '/api/graphql',
  })(req, res)
})

export const config = {
  api: {
    bodyParser: false,
  },
}
```

**apollo client**

`pages/_app.tsx`:
```tsx
import '../styles/globals.css'
import type { AppProps } from 'next/app';
import {ApolloClient,ApolloProvider,InMemoryCache,HttpLink,gql} from "@apollo/client";

/*
Como indica el error, tendrá que usar una URL absoluta para lo fetchque está haciendo. Supongo que tiene algo que ver con los diferentes entornos (cliente y servidor) en los que se puede ejecutar su código. Las URL relativas simplemente no son lo suficientemente explícitas y confiables en este caso.
*/
const client = new ApolloClient({
  cache: new InMemoryCache(),
  link: new HttpLink({
      uri: "http://localhost:3000/api/graphql"
  })
})

const query = gql`
  query ViewerQuery {
    allPersons{
      name
    }
  }
`
client.query({ query: query}).then(res => {
  console.log(res.data)
})

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ApolloProvider client={client}>
      <Component {...pageProps} />
    </ApolloProvider>
  )
}

export default MyApp
```