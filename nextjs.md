# [NEXT.JS](https://nextjs.org/)

## Inicializacion

Para inicializar una proyecto con nextjs usaremos el coamando:
```
npx create-next-app nombre_proyect
```
Si tambien queremos usar typescript con nextjs usamos:
```
npx create-next-app@latest nombre_proyect --ts
```

Se podran usar los comandos:
`npm run dev`
    Starts the development server.

`npm run build`
    Builds the app for production.

`npm start`
    Runs the built app in production mode.

Antes que nada utilizaremos el comando:
```
npm run dev
```
ESto para que se cree la capeta de .next que es necesaria para que funcione todo bien.

### Estructura de carpetas

En esta ocacion vamos a usar next + typescript


Se creo una carpeta llamada `pages` en esta existe el `index` de nuestra aplicacion(donde esta todo el contenido de la aplicacion). Dentro de `pages` tambien existe un derectorio para las `api`.

Dentro del archivo `pages/index.tsx`:
```tsx  
import Head from 'next/head';
// importa una utilidad que tiene nextjs para cambiar todo lo que tiene envuelto de head
//head es la etiqueta html especial para el title, la description, metadatos, etc

//una eejmplo de uso seria:
<Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
</Head>
```

**_app.tsx**
Este es un fichero especial, se encuentra en `pages/_app.tsx`. Este fichero detecta cuando se quiere hacer un componente que es el que envuelve la aplicacion.

Se pueden encontrar otras soluciones o usar este fichero.

**_document**
Similar al _app pero este se encuentra en una escala mas profunda ya que te puedes meter con el html tambien.

Algo que tomar en cuenta es que el document esta renderizado en el servidor, solo se renderiza en el servidor y no se renderiza en el cliente.

Aqui es donde se podria hacer uso del google analitics


### Crear rutas
Para crear una ruta mas simplemente tenemos que crear un directorio dentro de la carpteta `pages`. Ejemplo:
`pages/new_page/index.js`, se tiene que crear un index dentro del nuevo directorio para que se cree la ruta.

### Navegacion SPA

Si fuera un SPA no tendria que recargar la pagina sino que cargaria solamente lo que necesita.

```tsx
import Link from "next/link";
//en lugar de usar un a tenemos que sar un Link 
// asi usara el sistema de spa de nextjs y asi se evite recargar la apgina entera 

//<a href="/example">page example</a>
<Link href="/example">page example</Link>

//si llega a salir un error con los link entonces usarlos:
<Link href="/example">
<a>
page example
</a>
</Link>
```

**Fast Refresh**
Se hacen cambios en la pagina sin tener que reflescarla.

**newxt router**
```js
import {useRouter} from "next/router"
const router = useRouter();
const.log(router)
```

**componentes**
Para integrar componentes tenemos que crear la carpeta `components` al mismo nivel que la carpeta `pages` **no** dentro de la carpeta `pages`.


### Obtener datos en Next.js

Al obtener datos con Next.js, tiene algunas opciones sobre cómo desea obtener esos datos.

Primero, puede ir a la ruta del lado del cliente y realizar la solicitud una vez que se carga la página. El problema con esto es que le estás poniendo la carga al cliente para que se tome el tiempo de hacer esas solicitudes.

Las API de Next.js gustan `getStaticProps` y `getServerSideProps` le permiten recopilar datos en diferentes partes del ciclo de vida, lo que nos brinda la oportunidad de crear una aplicación completamente estática o una que se represente en el lado del servidor. Eso servirá los datos ya representados en la página directamente al navegador.

Al usar uno de esos métodos, podemos solicitar datos junto con nuestras páginas e inyectar esos datos como accesorios directamente en nuestra aplicación.

## Next.js + Apollo + GraphQL 

Para comenzar a realizar una consulta GraphQL, necesitaremos un cliente GraphQL. Usaremos el cliente Apollo GraphQL.

De vuelta dentro de la terminal, ejecute el siguiente comando para instalar nuestras nuevas dependencias:

```
npm install @apollo/client graphql
```

Esto agregará el cliente Apollo y GraphQL, que necesitaremos para formar la consulta GraphQL.

Y una vez que se complete la instalación, estaremos listos para comenzar a usar Apollo Client.

### agregar datos a una página Next.js con getStaticProps

Antes de obtener datos con Apollo, vamos a configurar nuestra página para poder solicitar datos y luego pasar esos datos como apoyo a nuestra página en el momento de la compilación.

Definamos una nueva función en la parte inferior de la página debajo de nuestro Homecomponente llamada getStaticProps:

```js
export async function getStaticProps() {
  // Code will go here
}
```
Cuando Next.js construye nuestra aplicación, sabe buscar esta función. Entonces, cuando lo exportamos, le informamos a Next.js que queremos ejecutar el código en esa función.

Dentro de nuestra `getStaticProps` función, finalmente devolveremos nuestros accesorios a la página. Para probar esto, agreguemos lo siguiente a nuestra función:
```js
export async function getStaticProps() {
  return {
    props: {
      launches: []
    }
  }
}
```

Aquí, estamos pasando una nueva propiedad `launches` y configurándola en una matriz vacía.

Ahora, volviendo al interior de nuestro Homecomponente, agreguemos un nuevo argumento desestructurado que servirá como nuestro accesorio junto con una `console.log` declaración para probar nuestro nuevo accesorio:

Si recargamos la página, podemos ver que ahora estamos desconectando nuestra nueva propiedad `launches` que incluye una matriz vacía tal como la definimos.

Lo mejor de esto es que, dado que la `getStaticProps` función que estamos creando es asíncrona, podemos realizar cualquier solicitud que deseemos (incluida una consulta de GraphQL) y devolverla como accesorios a nuestra página, que es lo que haremos a continuación. 

### Obtener datos con una consulta GraphQL en Next.js usando Apollo Client

Ahora que nuestra aplicación está preparada para agregar accesorios a la página y tenemos Apollo instalado, finalmente podemos hacer una solicitud para obtener nuestros datos.

Aquí, vamos a utilizar el cliente Apollo, que nos permitirá interactuar con el servidor SpaceX GraphQL. Haremos nuestra solicitud a la API utilizando el método getStaticProps de Next.js, lo que nos permitirá crear accesorios de forma dinámica para nuestra página cuando se construya.

Primero, importemos nuestras dependencias de Apollo al proyecto. En la parte superior de la página agregue:

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';
```
Esto incluirá el propio Apollo Client, `InMemoryCache` que permite a Apollo optimizar mediante la lectura de la memoria caché, y `gql` que usaremos para formar nuestra consulta GraphQL.

A continuación, para usar Apollo Client, debemos configurar una nueva instancia de este.

Dentro de la parte superior de la getStaticPropsfunción, agregue:
```js
const client = new ApolloClient({
  uri: 'https://api.spacex.land/graphql/',
  cache: new InMemoryCache()
});
```

Esto crea una nueva instancia de Apollo Client usando el extremo de la API de SpaceX que usaremos para consultar.

Con nuestro cliente, por fin podemos hacer una consulta. Agregue el siguiente código debajo del cliente:

```js
const { data } = await client.query({
  query: gql`
    query GetLaunches {
      launchesPast(limit: 10) {
        id
        mission_name
        launch_date_local
        launch_site {
          site_name_long
        }
        links {
          article_link
          video_link
          mission_patch
        }
        rocket {
          rocket_name
        }
      }
    }
  `
});
```

Esto hace algunas cosas:

- Crea una nueva consulta GraphQL dentro de la `gql` etiqueta
- Crea una nueva solicitud de consulta usando `client.query`.
- Se utiliza `await` para asegurarse de que finaliza la solicitud antes de continuar.
- Y finalmente se desestructura `   ` a partir de los resultados, que es donde se almacena la información que necesitamos

Dentro de la consulta de GraphQL, le estamos diciendo a la API de SpaceX que queremos obtener `launchesPast`, que son los lanzamientos anteriores de SpaceX, y queremos obtener los últimos 10 (límite). Dentro de eso, definimos los datos que nos gustaría consultar.

Si nos tomamos un segundo para agregar una nueva declaración de registro de la consola después de eso, podemos ver cómo `data` se ve.

Sin embargo, una vez que actualice la página, notará que no está viendo nada dentro de la consola del navegador.

`getStaticProps` se ejecuta durante el proceso de compilación, lo que significa que se ejecuta en node. Por eso, podemos mirar dentro de nuestra terminal y podemos ver nuestros registros allí:

Después de ver eso, sabemos que dentro del `data` objeto tenemos una propiedad llamada `launchesPast`, que incluye una serie de detalles de lanzamiento.

Ahora, podemos actualizar nuestra declaración de devolución para usar `launchesPast`:

Y si volvemos a agregar nuestra `console.log` declaración en la parte superior de la página para ver cómo se ve nuestro `launches` accesorio, podemos ver que nuestros datos de lanzamiento ahora están disponibles como un accesorio para nuestra página:
```js
return {
  props: {
    launches: data.launchesPast
  }
}
```



### agregar datos de lanzamiento de SpaceX a la página

Tenemos nuestros datos de lanzamiento que pudimos usar Apollo Client para solicitar del servidor SpaceX GraphQL. Hicimos esa solicitud `getStaticProps` para que pudiéramos hacer que nuestros datos estén disponibles como el `launches` accesorio que contiene nuestros datos de lanzamiento.

Indagando en la página, vamos a aprovechar lo que ya existe. Por ejemplo, podemos comenzar actualizando la `h1` etiqueta y el párrafo debajo de ella a algo que describa nuestra página un poco mejor.

A continuación, podemos usar las tarjetas de enlace ya existentes para incluir toda nuestra información de lanzamiento.

Para hacer esto, primero agreguemos una declaración de mapa dentro de la cuadrícula de la página, donde el componente que devolvemos es una de las tarjetas, con los detalles de lanzamiento completados:

```js
<div className={styles.grid}>
  {launches.map(launch => {
    return (
      <a key={launch.id} href={launch.links.video_link} className={styles.card}>
        <h3>{ launch.mission_name }</h3>
        <p><strong>Launch Date:</strong> { new Date(launch.launch_date_local).toLocaleDateString("en-US") }</p>
      </a>
    );
  })}
```

Desde aquí, podemos incluir cualquier dato adicional desde el interior de nuestra `launches` matriz en nuestra página. La API incluso incluye imágenes de parches de misión, que podemos usar para mostrar buenos gráficos para cada lanzamiento.

Incluso puede agregar datos adicionales a la consulta de GraphQL. Cada lanzamiento tiene mucha información disponible, incluido el equipo de lanzamiento y más detalles sobre el cohete.


 para saber si estar en el servirdor o en el cliente:
typeof window !== "undefined"

https://www.youtube.com/watch?v=2jxc8DMzt0I

1:11:00
## NEXTJS + MONGOB

Mongodb nos da un modulo para node para poder conectarlo pero en esta ocacion vamos a usar un modulo especial de mongodb llamado [mongoose](https://mongoosejs.com/),que es basicammente un modulo que nos permite conectarnos a la base de datos y tambien a su vez modelar los datos, es decir, decirle a mongodb que es lo que vamos a estar guardando dentro de la base de datos.


Despues abriremos el archivo `pages/api/hello.ts/`

SI queremos abrir este archivo desde el navegador entonces encendemos el servidor e ingresamos a la ruta:
```
localhost:3000/api/hello
```
ESto va a mostrar un objeto `.json`, es un objeto por que por lo general el backend devuelve objetos `.json` como forma de dar datos al cliente.

Next por debajo usar `express`.

Ahora crearemos un nueva nueva carpeta `pages/api/tasks/`, esta carpeta `tasks` nos va a servir para crear un CRUD  de tareas, es decir, vamos a crear los endpoinds o urls basicos que nos van a permitir crear tareas en el backend, eliminar, actualizar y obtener una unica tarea.

Ahora vamos a crear un archivo  `pages/api/tasks/index.js` y dentro de el vamos a escribir:
```ts
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json("tasks")
}


```

SI queremos abrir este archivo desde el navegador e ingresamos a la ruta:
```
localhost:3000/api/tasks
```
nos aparecera el string `tasks`

ahora vamos a instalara `mongoose`:
```
npm i mongoose
```

y vamos a crear un nuevo archivo al mismo nivel que `packagejson`, este archivo se va a nombrar `.env`, dentro de esta archivo vamos a escribir la direccion de la base de datos de mongodb(como variable de entorno)
```
MONGO_URL= mongodb://localhost:27017/nextjsmongodb
``` 
nuestra base de datos, en esta ocacion, se va a llamar `nextjsmongodb`.
Nosotros no tenemos que crear esta base de datos, en mongodb cuando nos conectamos a una base de datos este lo crea por nosotros.

Ahora si vemos el `.gitignore` se puede observar que esta ignorando:
```js
.env.local
.env.development.local
.env.test.local
.env.production.local
```
y vamos a agregar el `.env` para que no se suba a github:
```js
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
```

En lugar de un string lo que queremos devolver es una lista de tareas pero esas tareas tienen que estar guardadas en algun lugar y para eso necesito una base de datos.

Para conectarnos a una base de datos nosotros podemos crear una carpeta al mismo nivel que la carpeta `pages` **no** dentro de esta misma. En esta ocacion vamos a crear una carpeta con el nombre `utils` en esta carpeta podemos crear un archivo de conexion, es decir, un archivo que va a tener la conexion de la base de datos `utils/mongoose.ts`

`mongoose.ts`:
```ts
import {connect,connection} from "mongoose";
// connection da una serie de eventos para detectar cuando la coneccion se haya hecho, si ocurrio un error o si paso algo

export async function dbConect(){
    //dbConect lo que haces es inicialmente va intentar concetarse con la base de datos
    //pero para hacerlo tenermos que especificar a que base de datos se va a tener que concectar 
    // por lo general es comun que se le pase una direccion url de mongo db
    //pero a la hora de despegar la aplicacion no se va a querer colocar la direccion de la base de datos directamente en codigo asi que vamos a usar una variable de entorno del archivo .env
    const db: any = await connect(process.env.MONGO_URL)
    // lo anterior va a devolver un objeto db y si este existe va a devolver un estado
    //.readyState: para mostrar el estado, si esta listo o no
    console.log(db.connections[0].readyState)

}

connection.on("connected", ()=>{
    console.log("Mongodb is connected")
})

connection.on("error", (err)=>{
    console.log(err)
})
```

ahora en el archivo de `pages/api/tasks/index.ts` vamos a importar `mongoose.ts`:
```ts
import type { NextApiRequest, NextApiResponse } from 'next'
import {dbConect}  from "../../../utils/mongoose"
type Data = {
  name: string
}

dbConect()

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'tasks' })
}


```


Ahora tenemos que iniciar la base de datos de mongo:
```
mongod
```

si ocurero un error es por que `node` v17 prefiere las direcciones IPv6 a las IPv4. Pero mongo está configurado de manera predeterminada con ipv4.

- Configuración de IPv4
```
net:
  port: 27017
  bindIp: 127.0.0.1
```
- Configuración de IPv6
```
 net:
      ipv6: true
      port: 27017
      bindIpAll: true
```

en las rutas:
OSX path : `/usr/local/etc/mongod.conf`
Ubuntu Path: `/etc/mongod.conf`

Luego reinicie mongo.
```
sudo systemctl restart mongod
```

Algo que ocurre en nextjs es que cada vez que que estemos creando rutas para nuestro backend vamos a tener que estar importando la conexion a la base de datos, pero si importams el `dbConect` cada vez se va a crear una conexion nueva, para arreglar esto tenemos que guardar la conexion y poner una condicional, si ya existe la conexion vamos a utilizarla

```ts
import {connect,connection} from "mongoose";

const conn = {
    isConnected: false
  }
  

export async function dbConect(){

    //creamos una condiconal para usar la coneccion ya existente a la base de datos y asi no se creen nuevas con cada import a otros archivos
    if(conn.isConnected) return;
   
    const db: any = await connect(`${process.env.MONGO_URL}`);

    conn.isConnected = db.connections[0].readyState;

    console.log(db.connection.db.databaseName)

}

connection.on("connected", ()=>{
    console.log("Mongodb is connected")
})

connection.on("error", (err)=>{
    console.log(err)
})
```

### consultas mongodb en nexjs

Para hacer una consulta desde nexjs a mongodb tenemos que crear primero una carpeta con un archivo `models/task.ts` al mismo nivel que `pages` **no** dentro de esta misma.

Esta carpeta `models` va a contener un modelo de datos de lo que la base de datos tiene. Desntro del archivo `task.ts` escribimos:

```ts

```

https://www.youtube.com/watch?v=SiUM8vYeuu0

23:48